package matrix

import "math"

// Rank calculates the rank of a matrix using Gaussian elimination.
//
// The rank of a matrix is the dimension of the vector space generated by its columns,
// which equals the number of linearly independent rows or columns. Equivalently,
// it's the number of non-zero rows in the matrix's row echelon form.
//
// Parameters:
//   - m: Input matrix of type Matrix[T] where T is int or float64
//
// Returns:
//   - int: The rank of the matrix
//
// The algorithm transforms the matrix to its row echelon form (REF) using
// Gaussian elimination with partial pivoting for numerical stability,
// then counts the number of non-zero rows in the resulting REF matrix.
//
// For an empty matrix, the function returns 0.
// Time complexity: O(min(n,m) × n × m) where n is the number of rows and m is the number of columns.
func Rank[T int | float64](m Matrix[T]) int {
	// Validate matrix structure
	if err := m.Validate(); err != nil {
		// For rank calculation, we should still proceed even with inconsistent rows
		// but we need to ensure we have some data to work with
	}

	rows := len(m)
	if rows == 0 {
		return 0
	}

	cols := len(m[0])
	mat := cloneMatrix(m)

	row := 0
	rank := 0
	const epsilon = 1e-10 // Small value for numerical stability

	// Gaussian elimination to convert to row echelon form
	for col := 0; col < cols && row < rows; col++ {
		// Find pivot row with maximum absolute value in column
		pivotRow := row
		for i := row + 1; i < rows; i++ {
			if abs(mat[i][col]) > abs(mat[pivotRow][col]) {
				pivotRow = i
			}
		}

		// Skip column if no viable pivot found
		if math.Abs(float64(mat[pivotRow][col])) < epsilon {
			continue
		}

		// Swap rows
		mat[row], mat[pivotRow] = mat[pivotRow], mat[row]

		// Eliminate entries below the pivot
		for i := row + 1; i < rows; i++ {
			factor := mat[i][col] / mat[row][col]
			for j := col; j < cols; j++ {
				mat[i][j] -= factor * mat[row][j]
			}
		}
		row++
	}

	// Count non-zero rows to determine rank
	for i := range rows {
		nonZero := false
		for j := range cols {
			if math.Abs(float64(mat[i][j])) > epsilon {
				nonZero = true
				break
			}
		}
		if nonZero {
			rank++
		}
	}
	return rank
}
